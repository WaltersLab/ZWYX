---
title: "ZWYX: Introduction"
author: "James R. Walters"
package: "`r pkg_ver('ZWYX')`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{ZWYX: Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Overview

The ZWYX package aims to provide a streamlined workflow for identifying sex-linked regions of a genome assembly by comparing sequencing depth between males and females.

## Principles: Sex linkage and sequencing coverage

In species with differentiated sex chromosomes, the X or Z chromosomes should show a two-fold difference in sequencing coverage between sexes, while the sex-specific Y or W chromosomes should show an opposing and far more biased pattern of coverage. Autosomes should show no differences.

Using sex-specific sequencing coverage is an established method for identifying scaffolds derived from X, Y, W, or Z chromosomes. ZWYX provides data structures and functions for identifying and visualizing genome scaffolds with sex-biased coverage on average as a whole, but also via windows along each scaffold. 

ZWYX also incorporates "changepoint" algorithms for detecting shifts in sex-specific coverage that occur within a scaffold, which typically indicate a mis-assembly that erroneously joins autosomal and sex-linked regions.

## Workflow summary

-   **Input:** The starting point for ZWYX analysis is a table of read counts in regularly spaced windows across the genome, such as can be generated via [bedtools multicov](https://bedtools.readthedocs.io/en/latest/content/tools/multicov.html).
-   **Data Structure:** The table of read counts is combined with sample metadata (e.g. sex) in a `SummarizedExperiment` object.
-   **Normalization:** Read counts in each window are normalized for sequencing depth to allow meaningful comparisons between samples.
-   **Analysis:** Log2 ratios of read-coverage are calculated between sexes for each scaffold. Based on this statistic, scaffolds (or scaffold segments) are partitioned as being sex-linked or autosomal.
-   **Visualization:** Results are plotted, either as individual scaffolds or as windows along scaffolds with detected changepoints.

# Example Data

## Test case reference genome

As a test case for demonstrating the usage of ZWYX, we will use a manipulated version of the *Drosophila melanogaster* genome assembly. To approximate a structure typical of a newly *de novo* assembled draft genome, each chromosome arm was divided into log-scaled fragments. The X, 2L, 2R, 3L, and 3R portions were each split into 15 fragments, while the smaller Y and 4 chromosomes were each split into 7 fragments. Then a set of reciprocal translocations between autosomes and sex chromosomes were introduced into the fragmented assembly, as follows.

For the following the pairs of chromosomal fragments:

-   X.2 ↔ Auto 2L.2
-   X.4 ↔ Auto 2L.4
-   Y.1 ↔ Auto 2R.1

Two reciprocal translocations were introduced in each fragment:

| Start (Kbp) | Length (Kbp) |
|-------------|--------------|
| 150         | 500          |
| 850         | 50           |

Additionally, a different pair of translocations were created for

-   Y.3 ↔ Auto 2R.13

corresponding to:

| Start (Kbp) | Length (Kbp) |
|-------------|--------------|
| 100         | 100          |
| 400         | 25           |

This creates a reference genome with 89 scaffolds in it, 8 of which have manually induced sex-chromosome chimeras in them at known positions, which ZWYX can detect and categorize.

## Sex-specific Illumina data

To detect sex-specific sequencing coverage with ZWYX, we must first align Illumina sequencing data from male and female samples to the reference assembly. In our example, we will use 3 male and 3 female samples corresponding to "controls" in a [data set generated by Harbison *et al.* (2017).](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA369048) These sequencing data were aligned to the manipulated reference and for each sample reads were counted in 2000 bp windows across the genome.

The resulting read counts per window in each sample can be found in the `dmel_counts` dataframe provided with the ZWYX package.

```{r}
library(ZWYX)
data("dmel_counts")
head(dmel_counts)
```

# Example Analysis

## Initiating a `SummarizedExperiment` data structure
The `dmel_counts` dataframe is a representative starting point for using ZWYX. Functions in ZWYX generally assume that data are provided in a `SummarizedExperiment` object with rows structured as `GenomicRanges`. So the first step in a ZWYX analysis is to create the properly structured `SummarizedExperiment` object with the required metadata. (Please see the [vignette for `SummarizedExperiment`](https://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html) to learn more about this particular data structure)

Creating the needed `SummarizedExperiment` object from the `dmel_counts` dataframe is a three-step process. Before beginning, we will need to load the `SummarizedExperiment` package. 


**First**, we will create a `GenomicRanges` object to capture the window coordinates corresponding to read counts.

```{r}
suppressPackageStartupMessages( library(SummarizedExperiment) )
counts_ranges.dmel <- makeGRangesFromDataFrame(df = dmel_counts, seqnames.field = "scaffold")
counts_ranges.dmel
```

**Second**, we create a dataframe containing the relevant metadata for the samples.

```{r}
sample.dmel <- data.frame("sampleID" = names(dmel_counts)[-(1:3)],
                          "gamety" = c("Het","Het","Hom","Hom","Het","Hom")
               )
```

**NOTE:** The inclusion of the `gamety` column is **_essential_** for ZWYX functionality. The `gamety` column should be a character vector, with `"Het"` and `"Hom"` indicating "Heterogametic" and "Homogametic" according to sex chromosome complement of your study species. In _D. melanogaster_ , males carry the Y chromosome and are thus heterogametic.

**Third**, we combine these data structures together into a `SummarizedExperiment` object.
```{r}
count.se <- SummarizedExperiment(assays = list("counts" = dmel_counts[,-(1:3)]), 
                                 rowRanges = counts_ranges.dmel,
                                 colData = sample.dmel)
count.se
```


## Normalizing data
With the data properly structured in a `SummarizedExperiment` object, we can proceed with further analyses. An important first step is normalizing the data, which in this case just means accounting for overall depth of sequencing in each sample. This is accomplished by dividing each window's read count by a constant factor for a given sample. One simple option is to divide by the total reads aligned in that sample.

```{r}
norm.tot <- normalizeCounts(se = count.se, method = "totalreads")
norm.tot
```
This creates a second entry in `assays` corresponding to the normalized (and rescaled) values. These normalized values will be used by subsequent ZWYX functions for comparisons between sexes.

```{r}
head(assays(norm.tot)[["normdata"]])
```
ZWYX also provides an alternative option to normalize by median depth across windows, if desired.


## Assaying sex linkage by ratios

We can now use the normalized read counts to calculate coverage ratios for each scaffold. A ratio of mean values in each sex are reported as Log2(Heterogametic:Homogametic). Single representative values for each scaffold are based on sums across windows in each scaffold. 

Scaffolds are assigned to be "Autosomal", "X|Z", or "Y|W" depending on specific thresholds applied the Log2(Heterogametic:Homogametic). By default, the threshold is set at 0.5 and -0.5, respectively, but can be modified in the `getRatiosByScaff()` function. 
```{r}
scaffoldRatiosTot <- getRatiosByScaff(norm.tot)
head(scaffoldRatiosTot)
```


The resulting dataframe can be used directly for visualizing coverage ratios and assigned linkage.

```{r, fig.width=6}
library(ggplot2)
ggplot(data = scaffoldRatiosTot, aes(x=log10(scaffLen), y = log2homhet, col = Linkage)) + geom_point() +
          labs(y = "Log2(Female:Male)", x = "Log10(Fragment Length)") + 
   scale_color_manual(values = c("black","red", "blue")) + theme_light()
```

In this case, since the reference assembly was engineered, we can check these linkage assignments against what the true chromosomal linkage is, and whether a chromosome fragment (e.g. "scaffold") carried a translocation and thus was _chimeric_.

```{r, fig.width = 6}

scaffoldRatiosTot$chimera <- grepl(x = scaffoldRatiosTot$scaffold, pattern="chimera")
scaffoldRatiosTot$chrom <- gsub(x=scaffoldRatiosTot$scaffold, 
                                pattern = "(\\w)\\w?\\..*", rep="\\1", perl = T)

ggtot <- ggplot(data = scaffoldRatiosTot, aes(x=log10(scaffLen), y = log2homhet, 
               col = chimera, pch = chrom)) + geom_point() + 
               scale_color_manual(values = c("black","red"))  + 
               labs(y = "Log2(Female:Male)", x = "Log10(Fragment Length)") + 
               theme_light()
print(ggtot) 
```


# Changepoint analysis

This analysis that assigns whole scaffolds as being autosome or sex-linked rests on the assumption that the assembly is correct. However, assembly errors may commonly occur that result in scaffolds which erroneously join sex-linked and autosomal regions of the genome. Such chimeric scaffolds should produce sharp changes in sex-specific sequencing coverage along the scaffold, which can be detected by "changepoint" algorithms. 

ZWYX applies algorithms from [the `changepoint` package](https://CRAN.R-project.org/package=changepoint) to detect shifts in sequencing coverage ratios along single scaffold using read counts from each window. As above with analyses of whole scaffolds, segments with mean values above or below specific thresholds are assigned to be sex-linked.

The `runChangepointOnSE` function analyzes all scaffolds present in the provided `SummarizedExperiment` object and returns results for each scaffold in a list.

```{r}
cp.out <- runChangepointOnSE(se = norm.tot)
```

 For each scaffold it returns a list of length 4, comprised of:

1) `$InputGR` A GenomicRanges representation of log2(ratio) data input to the changepoint algorithm
2) `$SegmentsGR` A GenomicRanges represntation of the segments detected by changepoint analysis
3) `$Changepoint` The `changepoint` object output directly from the `cpt.mean()` function
4) `$FilteredWindows` A vector of indices corresponding to windows in `$InputGR`(1) which had `Inf` coverage ratios and thus (if any) were excluded from the Changepoint analysis.

Here is an example of an autosomal fragment engineered to contain two X-linked segments

```{r}
cp.out[["2L.2_5878429_9317088_chimeraAX"]]
```


While this output comprehensively captures the analysis, it is also cumbersome. Furthermore, adjacent segments may be detected which share the same linkage assignments. (For instance, adjacent segments with Log2(Het:Hom) of -1.3 and -1.7, respectively, will both be considered Y-like). So it is often desirable to distill these results into a single summary object with `mergeSegment()`, which produce either a dataframe or GRangesList object. 


Here is an example for the dataframe output. Note that the Log2(Het:Hom) statistic is removed from this output, since that statistic is determined by segment. With segments being merged, this statistic is dropped.


```{r}
outsegs.df <- mergeSegments(changeList = cp.out[1:3], asDF = TRUE)
head(outsegs.df)
```



# Visualizing Segments

The results of `runChangepointOnSE()` can be visualized for each scaffold using the `zwyxPlot()` function.

```{r, fig.width=7}
# Extract a known chimeric scaffold for demonstration
cp <- cp.out[[2]]
zwyxPlot(InputGR = cp[[1]], SegmentGR = cp[[2]], bpunit = "mbp", 
         pch = 19, cex = 0.2, seglwd = 3, main = unique(seqnames(cp[[1]])) ,
         xlab = "Position (Mbp)", ylab = "Log2(Het:Hom")
```

The function uses the GenomicRanges object of Log2(Het:Hom) ratios, and also of the detected changepoint segments, which are the first two elements that are produced by the function `runChangepointOnSE()`.  

In our example data, we can look at all of the engineered "chimeric" scaffolds using `zwyxPlot()`. 

```{r, fig.height=10, fig.width=7}
chimera.ind <- which(scaffoldRatiosTot$chimera)


par(mfrow = c(4,2))
for (nscaff in chimera.ind) {
   zwyxPlot(InputGR = cp.out[[nscaff]][[1]], SegmentGR = cp.out[[nscaff]][[2]], 
            bpunit="mbp", pch = 19, cex = .2, seglwd = 3, 
            main = names(cp.out [nscaff]),  xlab = "Position (Mbp)", ylab = "Log2(Het:Hom" )
}
```

